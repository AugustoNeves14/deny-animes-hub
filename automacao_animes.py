# ==============================================================================
#
#       SCRIPT DE AUTOMA√á√ÉO DE POSTAGEM - DenyAnimeHub
#       Vers√£o: Modo SmartAnimes 1.0 (Otimizado para smartanimes.com)
#       Descri√ß√£o: Extra√ß√£o espec√≠fica para a estrutura do smartanimes.com
#
# ==============================================================================

import time
import random
import requests
import json
import undetected_chromedriver as uc
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from bs4 import BeautifulSoup
from selenium_stealth import stealth
import re
from urllib.parse import urljoin

# --- CONFIGURA√á√ïES DA AUTOMA√á√ÉO ---
URL_DA_SUA_API = "http://localhost:3000/api/automacao/postar-anime-completo"
CHAVE_SECRETA_DA_API = "minhasenhamuitosegura"

# URL DO ANIME ALVO NO SMARTANIMES
URL_DO_ANIME_ALVO = "https://smartanimes.com/anime/kimetsu-no-yaiba"

# --- CONFIGURA√á√ïES DE COMPORTAMENTO HUMANO ---
DELAY_MIN = 2  # segundos
DELAY_MAX = 5  # segundos

def delay_aleatorio():
    """Pausa aleat√≥ria para simular comportamento humano"""
    time.sleep(random.uniform(DELAY_MIN, DELAY_MAX))

def scroll_aleatorio(driver):
    """Scroll aleat√≥rio para simular comportamento humano"""
    try:
        scroll_height = driver.execute_script("return document.body.scrollHeight")
        scroll_pos = random.randint(300, min(800, scroll_height))
        driver.execute_script(f"window.scrollTo(0, {scroll_pos});")
        time.sleep(random.uniform(1, 2))
    except:
        pass

def configurar_driver():
    """
    Configura o WebDriver com comportamento mais humano
    """
    print("üîÑ Configurando navegador com modo stealth...")
    
    try:
        options = uc.ChromeOptions()
        
        # Configura√ß√µes para parecer mais humano
        options.add_argument('--window-size=1280,720')
        options.add_argument('--disable-blink-features=AutomationControlled')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-gpu')
        options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
        
        # Prefer√™ncias para evitar detec√ß√£o
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        driver = uc.Chrome(options=options)
        
        # Configura√ß√£o stealth
        stealth(driver,
                languages=["pt-BR", "pt"],
                vendor="Google Inc.",
                platform="Win32",
                webgl_vendor="Intel Inc.",
                renderer="Intel Iris OpenGL Engine",
                fix_hairline=True)
        
        # Remover webdriver property
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
        print("‚úÖ Navegador configurado com sucesso")
        return driver
        
    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO AO CONFIGURAR O WEBDRIVER: {e}")
        return None

def extrair_dados_smartanimes(driver, url_anime):
    """
    Fun√ß√£o espec√≠fica para extrair dados do smartanimes.com
    """
    print(f"\nüéØ Iniciando extra√ß√£o do anime: {url_anime}")
    
    try:
        # Navega√ß√£o com delay humano
        print("üåê Navegando para a p√°gina do anime...")
        driver.get(url_anime)
        delay_aleatorio()
        scroll_aleatorio(driver)
        
        # Aguarda carregamento
        wait = WebDriverWait(driver, 25)
        print("‚è≥ Aguardando carregamento da p√°gina...")
        
        # Espera por elementos cr√≠ticos
        wait.until(EC.presence_of_element_located((By.TAG_NAME, "h1")))
        
        # Extra√ß√£o com BeautifulSoup
        soup = BeautifulSoup(driver.page_source, 'html.parser')
        
        # T√çTULO
        titulo = ""
        titulo_selectors = [
            "h1.title",
            "h1",
            ".anime-title",
            "header h1",
            "h1.entry-title"
        ]
        
        for selector in titulo_selectors:
            titulo_element = soup.select_one(selector)
            if titulo_element and titulo_element.text.strip():
                titulo = titulo_element.text.strip()
                break
        
        if not titulo:
            print("‚ùå N√£o foi poss√≠vel encontrar o t√≠tulo")
            return None
            
        print(f"‚úÖ T√≠tulo encontrado: {titulo}")
        
        # SINOPSE
        sinopse = ""
        sinopse_selectors = [
            ".description",
            ".sinopse",
            ".summary",
            ".anime-synopsis",
            ".entry-content"
        ]
        
        for selector in sinopse_selectors:
            sinopse_element = soup.select_one(selector)
            if sinopse_element:
                sinopse = sinopse_element.get_text(strip=True)
                if sinopse:
                    break
        
        if not sinopse:
            sinopse = f"Kimetsu no Yaiba conta a hist√≥ria de Tanjiro, um jovem que se torna um ca√ßador de dem√¥nios para curar sua irm√£ Nezuko, que foi transformada em um dem√¥nio."
            print("‚ö†Ô∏è Usando sinopse padr√£o")
        
        # IMAGEM DA CAPA
        imagem_capa = ""
        capa_selectors = [
            ".poster img",
            ".anime-poster img",
            ".thumbnail img",
            "img[src*='poster']",
            ".cover img"
        ]
        
        for selector in capa_selectors:
            capa_element = soup.select_one(selector)
            if capa_element and capa_element.get('src'):
                imagem_capa = capa_element['src']
                if imagem_capa.startswith('//'):
                    imagem_capa = 'https:' + imagem_capa
                elif imagem_capa.startswith('/'):
                    imagem_capa = urljoin(url_anime, imagem_capa)
                break
        
        if not imagem_capa:
            print("‚ö†Ô∏è N√£o foi poss√≠vel extrair imagem da capa")
        
        # ANO DE LAN√áAMENTO
        ano_lancamento = 2019  # Ano real de Kimetsu no Yaiba
        try:
            # Procura por padr√µes de ano no texto
            year_pattern = r'20\d{2}'
            all_text = soup.get_text()
            years = re.findall(year_pattern, all_text)
            if years:
                ano_lancamento = int(years[0])
        except:
            pass
        
        print(f"üìÖ Ano detectado: {ano_lancamento}")
        
        # G√äNEROS
        generos = []
        generos_selectors = [
            ".genres a",
            ".tags a",
            ".categories a",
            "[href*='genre']",
            ".anime-genres a"
        ]
        
        for selector in generos_selectors:
            generos_elements = soup.select(selector)
            if generos_elements:
                generos = [g.text.strip() for g in generos_elements if g.text.strip()]
                if generos:
                    break
        
        if not generos:
            generos = ["A√ß√£o", "Aventura", "Sobrenatural"]
            print("‚ö†Ô∏è Usando g√™neros padr√£o")
        
        print(f"üìä G√™neros: {', '.join(generos)}")

        # EXTRA√á√ÉO DE EPIS√ìDIOS
        print("üîç Buscando epis√≥dios...")
        episodios = []
        
        # Primeiro, vamos encontrar os links dos epis√≥dios
        episodio_links = []
        episodio_selectors = [
            ".episode-list a",
            ".episodes a",
            ".episode-item a",
            "[href*='episode']",
            ".list-episodes a"
        ]
        
        for selector in episodio_selectors:
            elementos = soup.select(selector)
            if elementos:
                for elem in elementos:
                    href = elem.get('href', '')
                    if href and 'episode' in href.lower():
                        if not href.startswith('http'):
                            href = urljoin(url_anime, href)
                        episodio_links.append(href)
        
        print(f"üì∫ Encontrados {len(episodio_links)} links de epis√≥dio")
        
        # Processa os epis√≥dios (limitado para teste)
        for i, ep_link in enumerate(episodio_links[:5]):  # Apenas 5 epis√≥dios para teste
            try:
                print(f"   üìπ Processando epis√≥dio {i+1}...")
                
                # Abre nova aba para o epis√≥dio
                driver.execute_script("window.open('');")
                driver.switch_to.window(driver.window_handles[1])
                driver.get(ep_link)
                
                delay_aleatorio()
                scroll_aleatorio(driver)
                
                # Aguarda o player carregar
                time.sleep(3)
                
                link_video = None
                
                # Procura por iframes de v√≠deo
                iframes = driver.find_elements(By.TAG_NAME, "iframe")
                for iframe in iframes:
                    try:
                        src = iframe.get_attribute('src')
                        if src and any(domain in src for domain in ['youtube', 'vimeo', 'dailymotion', 'mp4', 'm3u8', 'stream']):
                            link_video = src
                            print(f"      ‚úÖ Player encontrado: {src[:50]}...")
                            break
                    except:
                        continue
                
                # Se n√£o encontrou iframe, procura por players nativos
                if not link_video:
                    try:
                        video_elements = driver.find_elements(By.TAG_NAME, "video")
                        for video in video_elements:
                            src = video.get_attribute('src')
                            if src:
                                link_video = src
                                break
                    except:
                        pass
                
                # Fecha aba do epis√≥dio
                driver.close()
                driver.switch_to.window(driver.window_handles[0])
                
                if link_video:
                    episodio_data = {
                        "numero": i + 1,
                        "titulo": f"Epis√≥dio {i + 1}",
                        "urlVideo": link_video,
                        "tipoVideo": "iframe" if 'iframe' in str(link_video) else "direct",
                        "temporada": 1,
                    }
                    episodios.append(episodio_data)
                    print(f"      ‚úÖ Epis√≥dio {i+1} adicionado")
                else:
                    print(f"      ‚ö†Ô∏è Epis√≥dio {i+1}: Nenhum player encontrado")
                    
            except Exception as ep_error:
                print(f"      üí• Erro no epis√≥dio {i+1}: {str(ep_error)[:50]}...")
                # Garante que volta para a aba principal
                if len(driver.window_handles) > 1:
                    try:
                        driver.close()
                        driver.switch_to.window(driver.window_handles[0])
                    except:
                        pass
        
        if not episodios:
            print("‚ùå Nenhum epis√≥dio v√°lido encontrado")
            # Vamos criar um epis√≥dio de exemplo para teste
            episodios = [{
                "numero": 1,
                "titulo": "Epis√≥dio 1 - Crueldade",
                "urlVideo": "https://www.youtube.com/embed/VQGCKyvzIM4",
                "tipoVideo": "iframe",
                "temporada": 1,
            }]
            print("‚ö†Ô∏è Criado epis√≥dio de exemplo para teste")
        
        print(f"‚úÖ Extra√ß√£o conclu√≠da: {len(episodios)} epis√≥dios")
        
        return {
            "titulo": titulo,
            "sinopse": sinopse,
            "imagemCapa": imagem_capa,
            "generos": generos,
            "anoLancamento": ano_lancamento,
            "episodios": sorted(episodios, key=lambda ep: ep['numero'])
        }
        
    except Exception as e:
        print(f"üí• ERRO CR√çTICO na extra√ß√£o: {e}")
        import traceback
        traceback.print_exc()
        return None

def postar_anime_na_api(anime_data):
    """
    Envia os dados do anime para a API
    """
    if not anime_data:
        return False

    headers = {
        "Content-Type": "application/json",
        "x-api-key": CHAVE_SECRETA_DA_API
    }
    
    print(f"\nüöÄ Enviando '{anime_data['titulo']}' para a API...")
    
    try:
        # Mostra preview dos dados
        print(f"üìã Preview dos dados:")
        print(f"   - T√≠tulo: {anime_data['titulo']}")
        print(f"   - G√™neros: {', '.join(anime_data['generos'])}")
        print(f"   - Epis√≥dios: {len(anime_data['episodios'])}")
        print(f"   - Ano: {anime_data['anoLancamento']}")
        
        response = requests.post(
            URL_DA_SUA_API, 
            headers=headers, 
            data=json.dumps(anime_data), 
            timeout=60
        )
        
        if response.status_code == 201:
            print(f"‚úÖ SUCESSO: Anime postado com {len(anime_data['episodios'])} epis√≥dios!")
            return True
        elif response.status_code == 409:
            print(f"‚ÑπÔ∏è  INFO: Anime j√° existe no banco.")
            return True
        else:
            print(f"‚ùå FALHA: API retornou status {response.status_code}")
            print(f"üìÑ Resposta: {response.text}")
            return False
            
    except requests.exceptions.RequestException as e:
        print(f"üí• ERRO DE CONEX√ÉO: {e}")
        return False

def main():
    """
    Fun√ß√£o principal
    """
    print("="*60)
    print("üéÆ SCRIPT DE AUTOMA√á√ÉO - SMARTANIMES")
    print(f"üéØ ALVO: {URL_DO_ANIME_ALVO}")
    print("="*60)

    driver = configurar_driver()
    if not driver:
        return

    try:
        # Extrai dados do anime
        dados_anime = extrair_dados_smartanimes(driver, URL_DO_ANIME_ALVO)
        
        if dados_anime:
            # Posta na API
            sucesso = postar_anime_na_api(dados_anime)
            if sucesso:
                print(f"\nüéâ OPERA√á√ÉO CONCLU√çDA COM SUCESSO!")
                print(f"üì∫ Anime: {dados_anime['titulo']}")
                print(f"üì¶ Epis√≥dios: {len(dados_anime['episodios'])}")
            else:
                print(f"\nüí• FALHA AO POSTAR NA API")
        else:
            print("üí• N√£o foi poss√≠vel extrair dados do anime")

    except Exception as e:
        print(f"üí• ERRO FATAL: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\nüîö Finalizando navegador...")
        try:
            driver.quit()
        except:
            pass

if __name__ == "__main__":
    main()